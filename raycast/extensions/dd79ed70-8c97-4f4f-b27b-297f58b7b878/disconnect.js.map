{
  "version": 3,
  "sources": ["../src/disconnect.tsx", "../src/lib.ts"],
  "sourcesContent": ["import { PopToRootType, Toast, showHUD, showToast } from \"@raycast/api\";\nimport { ConnectionStatus, disconnectFromWarp, getWarpStatus } from \"./lib\";\n\nexport default async () => {\n  try {\n    const statusResult = await getWarpStatus();\n    if (statusResult.status === ConnectionStatus.Disconnected) {\n      await showHUD(\"Not connected\", {\n        clearRootSearch: true,\n        popToRootType: PopToRootType.Immediate,\n      });\n      return;\n    }\n    const disconnectionResult = await disconnectFromWarp();\n    if (disconnectionResult) {\n      await showHUD(\"Disconnected\", {\n        clearRootSearch: true,\n        popToRootType: PopToRootType.Immediate,\n      });\n      return;\n    }\n\n    throw new Error(\"Failed to disconnect\");\n  } catch (e) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Failed to disconnect\",\n    });\n  }\n};\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { exec } from \"child_process\";\nimport util from \"util\";\nconst execPromise = util.promisify(exec);\n\nconst preferences: { wrapCliPath: string } = getPreferenceValues();\nconst DEFAULT_WRAP_CLI_PATH = \"/Applications/Cloudflare WARP.app/Contents/Resources/warp-cli\";\nconst wrapCliCmd = preferences.wrapCliPath ?? DEFAULT_WRAP_CLI_PATH;\n\nexport function execCommand(cmd: string) {\n  return execPromise(`\"${wrapCliCmd}\" ${cmd}`);\n}\n\nexport async function connectToWarp(): Promise<boolean> {\n  try {\n    const { stdout } = await execCommand(\"connect\");\n    if (stdout.includes(\"Success\")) {\n      return true;\n    }\n    throw new Error(\"Failed to connect\");\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nexport async function disconnectFromWarp(): Promise<boolean> {\n  try {\n    const { stdout } = await execCommand(\"disconnect\");\n    if (stdout.includes(\"Success\")) {\n      return true;\n    }\n    throw new Error(\"Failed to connect\");\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n\nexport enum ConnectionStatus {\n  Connected = \"connected\",\n  Disconnected = \"disconnected\",\n  Unknown = \"unknown\",\n}\nexport type StatusResult = {\n  status: ConnectionStatus;\n  disconnectReason: string;\n};\nexport async function getWarpStatus(): Promise<StatusResult> {\n  const { stdout } = await execCommand(\"status\");\n  const lines = stdout.trim().split(\"\\n\");\n  if (lines.length < 2) {\n    return { status: ConnectionStatus.Disconnected, disconnectReason: \"unknown\" };\n  }\n  if (lines[1].includes(\"Disconnected\")) {\n    return {\n      status: ConnectionStatus.Disconnected,\n      disconnectReason: lines[1].substring(\"Status update: Disconnected. Reason: \".length),\n    };\n  }\n  if (lines[1].includes(\"Connected\")) {\n    return { status: ConnectionStatus.Connected, disconnectReason: \"\" };\n  }\n  return { status: ConnectionStatus.Unknown, disconnectReason: \"unknown\" };\n}\n\nexport type VirtualNetwork = {\n  id: string;\n  name: string;\n  comment: string;\n  default: boolean;\n  active: boolean;\n};\n\nexport async function getVirtualNetworks(): Promise<VirtualNetwork[]> {\n  const { stdout } = await execCommand(\"get-virtual-networks\");\n  const lines = stdout.trim().split(\"\\n\");\n  const currentlySelected = lines[1].split(\" \")[2]?.trim() ?? \"\";\n  const rawData = lines.slice(2).filter((line) => line !== \"\");\n\n  const networks = [];\n  let i = 0;\n  while (i < rawData.length) {\n    if (i + 4 > rawData.length) break;\n    const [id, name, comment, defaultNetwork] = rawData.slice(i, i + 4);\n    networks.push({\n      id: id.substring(4),\n      name: name.substring(6),\n      comment: comment.substring(8),\n      default: defaultNetwork.substring(9) === \"true\",\n      active: id.substring(4) === currentlySelected,\n    });\n    i += 4;\n  }\n  return networks;\n}\n\nexport async function switchVirtualNetwork(id: string): Promise<boolean> {\n  try {\n    const disconnected = await disconnectFromWarp();\n    if (!disconnected) {\n      throw new Error(\"Failed to disconnect\");\n    }\n    const { stdout } = await execCommand(`set-virtual-network ${id}`);\n    if (!stdout.includes(\"Success\")) {\n      throw new Error(\"Failed to switch network\");\n    }\n    const connectStatus = await connectToWarp();\n    if (!connectStatus) {\n      throw new Error(\"Failed to connect\");\n    }\n    return true;\n  } catch (e) {\n    console.error(e);\n    return false;\n  }\n}\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAyD,wBCAzD,IAAAC,EAAoC,wBACpCC,EAAqB,yBACrBC,EAAiB,mBACXC,EAAc,EAAAC,QAAK,UAAU,MAAI,EAEjCC,KAAuC,uBAAoB,EAC3DC,EAAwB,gEACxBC,EAAaF,EAAY,aAAeC,EAEvC,SAASE,EAAYC,EAAa,CACvC,OAAON,EAAY,IAAII,CAAU,KAAKE,CAAG,EAAE,CAC7C,CAeA,eAAsBC,GAAuC,CAC3D,GAAI,CACF,GAAM,CAAE,OAAAC,CAAO,EAAI,MAAMC,EAAY,YAAY,EACjD,GAAID,EAAO,SAAS,SAAS,EAC3B,MAAO,GAET,MAAM,IAAI,MAAM,mBAAmB,CACrC,OAASE,EAAG,CACV,eAAQ,MAAMA,CAAC,EACR,EACT,CACF,CAWA,eAAsBC,GAAuC,CAC3D,GAAM,CAAE,OAAAC,CAAO,EAAI,MAAMC,EAAY,QAAQ,EACvCC,EAAQF,EAAO,KAAK,EAAE,MAAM;AAAA,CAAI,EACtC,OAAIE,EAAM,OAAS,EACV,CAAE,OAAQ,eAA+B,iBAAkB,SAAU,EAE1EA,EAAM,CAAC,EAAE,SAAS,cAAc,EAC3B,CACL,OAAQ,eACR,iBAAkBA,EAAM,CAAC,EAAE,UAAU,EAA8C,CACrF,EAEEA,EAAM,CAAC,EAAE,SAAS,WAAW,EACxB,CAAE,OAAQ,YAA4B,iBAAkB,EAAG,EAE7D,CAAE,OAAQ,UAA0B,iBAAkB,SAAU,CACzE,CD7DA,IAAOC,EAAQ,SAAY,CACzB,GAAI,CAEF,IADqB,MAAMC,EAAc,GACxB,wBAA0C,CACzD,QAAM,WAAQ,gBAAiB,CAC7B,gBAAiB,GACjB,cAAe,gBAAc,SAC/B,CAAC,EACD,MACF,CAEA,GAD4B,MAAMC,EAAmB,EAC5B,CACvB,QAAM,WAAQ,eAAgB,CAC5B,gBAAiB,GACjB,cAAe,gBAAc,SAC/B,CAAC,EACD,MACF,CAEA,MAAM,IAAI,MAAM,sBAAsB,CACxC,MAAY,CACV,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,sBACT,CAAC,CACH,CACF",
  "names": ["disconnect_exports", "__export", "disconnect_default", "__toCommonJS", "import_api", "import_api", "import_child_process", "import_util", "execPromise", "util", "preferences", "DEFAULT_WRAP_CLI_PATH", "wrapCliCmd", "execCommand", "cmd", "disconnectFromWarp", "stdout", "execCommand", "e", "getWarpStatus", "stdout", "execCommand", "lines", "disconnect_default", "getWarpStatus", "disconnectFromWarp"]
}
